#include <sys/wait.h> /* wait */
#include <stdio.h>
#include <stdlib.h>   /* exit functions */
#include <unistd.h>   /* read, write, pipe, _exit */
#include <string.h>

#define ReadEnd  0
#define WriteEnd 1

void report_and_exit(const char* msg) {
  perror(msg);
  exit(-1);    /** failure **/
}

long readFromPipe(long *conversion,int virtualFileAddr, char *buffer){
	int readResult = read( virtualFileAddr, buffer, 20 );
	*conversion = strtol(buffer,NULL,10);
	return *conversion;
}

int isPrime(long n) 
{
	int i; 
	for (i = 2; i <= n / 2; ++i) 
	{
		if (n % i == 0)
            		return 0;
        }
	return 1;
}

int main() {
  int pipeFDs[2]; /* two file descriptors */
  char buf[20];       /*The consumer process will read 20 bytes from the buffer, that corresponds to one random number*/
  char stringConvertedInt[20];/*The producer will generate a random number and convert to string so it can be written in the pipe*/
  int N = 1;
  int totalNumbers = 10; /*Sets how many numbers should be generated by the producer process*/
  time_t t;
  srand((unsigned) time(&t));
  
  if (pipe(pipeFDs) < 0) report_and_exit("pipeFD");
  pid_t cpid = fork();                                /* fork a child process */
  if (cpid < 0) report_and_exit("fork");              /* check for failure */

  if (0 == cpid) {    /*** child ***/                 /* child process */
	close(pipeFDs[WriteEnd]);                         /* child reads, doesn't write */
	long conversion = 0;
	int keepExecuting = 1;
	while (keepExecuting)
	{ 
		readFromPipe(&conversion,pipeFDs[ReadEnd], buf); 
		if(conversion == 0)/* read until 0 is received */
		{
			keepExecuting = 0;
		}
		else
		{
			dprintf(STDOUT_FILENO,"%ld %s",conversion,isPrime(conversion)?"is prime\n":"is not prime\n" );        /* echo to the standard output */
			
		}
	}
		close(pipeFDs[ReadEnd]);                          /* close the ReadEnd: all done */
		_exit(0);                                         /* exit and notify parent at once  */
  }

  else {              /*** parent ***/
	close(pipeFDs[ReadEnd]);                          /* parent writes, doesn't read */
	while(totalNumbers > 0)
	{
		sprintf(stringConvertedInt, "%d", N);
		N += (1 + rand()%100 );
		totalNumbers--;
		write(pipeFDs[WriteEnd], &stringConvertedInt, sizeof(stringConvertedInt));       /* write the bytes to the pipe */
		
	}
	sprintf(stringConvertedInt, "%d", 0);
	write(pipeFDs[WriteEnd], &stringConvertedInt, sizeof(stringConvertedInt));   
	close(pipeFDs[WriteEnd]);                         /* done writing: generate eof */

	wait(NULL);                                       /* wait for child to exit */
	exit(0);                                          /* exit normally */
  }
  return 0;
}
